---
title: "分布式ID"
description: ""
summary: ""
date: 2024-10-10T09:00:00+08:00
lastmod: 2024-10-10T09:00:00+08:00
weight: 300
seo:
  title: "分布式ID"
  description: ""
  canonical: ""
  noindex: false
---

## Snowflake

Snowflake 是 Twitter 开发的一种高效分布式 ID 生成算法，能够生成全局唯一且递增的 64 位整数 ID。
它通过时间戳、机器 ID 和序列号的组合，确保了在分布式系统中生成的 ID 既唯一又有序。

### 算法原理

Snowflake 的 ID 是一个 64 位的长整型数，其中各部分有特定的分配方式：

* 1 位符号位：固定为 0，表示生成的 ID 是正数。
* 41 位时间戳：表示当前时间（相对于某个纪元的毫秒数），可以表示大约 69 年的时间。
* 10 位机器 ID：用来标识不同的机器或节点，5 位数据中心 ID 和 5 位机器 ID 组合。
* 12 位序列号：表示同一毫秒内生成的不同 ID，同一节点同一毫秒最多可以生成 4096 个 ID。

具体结构如下：

```txt {frame="none"}
| 1 bit | 41 bits 时间戳 | 5 bits 数据中心 ID | 5 bits 机器 ID | 12 bits 序列号 |
```

### 步骤详解

1. 时间戳：
   * 41 位的时间戳记录的是当前时间相对于某个自定义纪元（epoch）的毫秒数。通常会选择一个固定的时间作为开始，比如 2020-01-01 00:00:00 UTC。
   * 可以表示的最大时间范围为 (2^41 - 1) 毫秒，大约是 69 年。

2. 数据中心 ID 和机器 ID：
   * 通过将集群中的机器分配到不同的数据中心，再给每个数据中心分配唯一的机器 ID，从而区分不同的机器。
   * 这部分共用 10 位，最多支持 1024 个节点（32 个数据中心，每个数据中心 32 台机器）。

3. 序列号：
   * 12 位的序列号用于区分同一毫秒内同一节点生成的多个 ID，最大值为 4095（即每毫秒最多生成 4096 个 ID）。
   * 当序列号达到 4096 时，需要等待下一毫秒。

4. 符号位：
   * 最高位符号位固定为 0，表示生成的 ID 始终是正数。

### 生成过程

1. 获取当前时间的毫秒数，并与预定义的纪元时间相减，得到时间戳。
2. 获取数据中心和机器 ID，确保该机器的 ID 唯一。
3. 在同一毫秒内，如果生成的 ID 超过 4096，则等待到下一毫秒。
4. 将时间戳、数据中心 ID、机器 ID、序列号按顺序左移并组合成一个 64 位整数，生成唯一 ID。

### 如何实现

为了在 MySQL 中使用 Snowflake 生成分布式 ID，通常可以通过以下几种方式：

1. 通过应用层生成 ID：
   * 在应用程序中实现 Snowflake 算法（使用 Java、Go、Python 等语言），然后在插入数据时将生成的 ID 作为主键插入 MySQL。

2. 通过存储过程：
   * 在 MySQL 中编写存储过程来生成 Snowflake ID，但需要小心性能问题。

3. 使用分布式 ID 服务：
   * 可以将 Snowflake ID 的生成独立成服务，使用如 Redis 或 Zookeeper 等协调服务，或者使用已有的分布式 ID 生成库或工具，如 Twitter 的 Snowflake 实现库。

### 开源实现

Twitter 官方已经不维护了，不过可以在 GitHub 上找到一些第三方实现。

{{< link-card
  title="bwmarrin/snowflake"
  description="Golang"
  href="https://github.com/bwmarrin/snowflake"
  target="_blank"
>}}

### 优点缺点

* 高性能：Go 的并发模型非常高效，可以处理大量请求。
* 低延迟：生成 ID 的操作几乎是瞬时的，不依赖于数据库的响应时间。
* 可扩展性：可以轻松地添加更多节点来扩展 ID 生成能力。
* 独立性：不需要依赖数据库，减少了数据库的负担。

---

* 复杂性：需要管理服务的状态和配置，确保机器 ID 和时间戳的一致性。
* 需要同步：确保不同节点的时间同步，避免因时钟回退导致的 ID 冲突。

### 时钟回退

防止时钟退回是确保分布式 ID 生成器（如 Snowflake）正常工作的关键。以下是一些常用的方法：

1. 时间同步
   * NTP（网络时间协议）：使用 NTP 服务保持系统时钟同步，确保所有节点的时间一致。定期与时间服务器同步时间，减少时钟漂移。
2. 时间戳检查
   * 时间回退检测：在生成 ID 时，检查当前时间戳是否小于上次生成 ID 时的时间戳。如果发现时钟回退，可以选择：
     * 阻塞等待：等待直到系统时间恢复。
     * 抛出异常：返回错误，通知调用者处理。
3. 设置合理的时钟回退窗口
   * 容忍度：在生成 ID 的逻辑中引入一个小的容忍窗口，例如允许时间回退几毫秒，如果时钟回退超出该范围则采取措施。
4. 机器 ID 和实例隔离
   * 多实例设计：在不同的机器上运行多个实例，确保每个实例有唯一的机器 ID。如果某个实例出现时钟回退，可以切换到其他正常的实例。
5. Fallback 机制
   * 备用 ID 生成策略：当检测到时钟回退时，切换到备用的 ID 生成策略（例如，使用 UUID 或随机数），直到时钟恢复正常。

## 第三方工具

可使用 Etcd 和 Zookeeper，生成的 ID 通常是以字符串形式表示的，但可以转换为 64 位整型。

### Etcd

* 类型：通过自增操作生成的 ID 是整数，返回值通常是一个 64 位整型。
* 示例：调用 etcd.increment('unique_id') 后返回的值直接就是整型。

### Zookeeper

* 类型：Zookeeper 的顺序节点生成的 ID 是字符串形式，通常以节点路径的形式表示（如 /id_generator/id-0000000001）。
* 转换：可以通过解析节点名称中的序号部分，将其转换为 64 位整型。
